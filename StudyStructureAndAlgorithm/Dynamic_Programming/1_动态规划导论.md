# 1.动态规划导论

## 1.1 动态规划题目特点

1. ==计数== (count)

   有多少种方式走到右下角(机器人走方格问题)

   有多少种方法选出k个数使得和为sum(k-sum问题)

2. ==求最大最小值== (max/min) 
   从左上角到右小角的最长路径
   最长上升子序列长度
   
3. ==求存在性== (Y/N)
   约瑟夫环问题
   能否选出k个数使得和为sum

## 1.2 动态规划解题步骤

1. 确定状态
   即解动态规划需要开一个数组, 明确f[i]或f\[i][j] 代表什么
   确定状态的步骤:
   1. 确定最后一步
   2. 通过最后一步确定子问题 
2. 转移方程
   **通过最后一步和子问题确定转移方程**
3. 初始条件和边界条件
4. 计算顺序
   **一般的计算顺序都是从小到大**

## 1.3 例题

### 1.3.1   最值型

> 问题

硬币问题:

有2元, 3元, 5元硬币若干个, 求如何用==最少== 的硬币组合n元, 正好付清, 不需要对方找钱.

> 解题思路

最值问题, 尝试使用动态规划

1. **确定状态**        假设共需要k枚硬币

   1.  确定最后一步: 确定最后一枚硬币, 面值为$a_k$ 
   2.  最后一步的子问题: 需要用$k-1$ 枚硬币组合出$n-a_k$ 元

   关键点:

   1. 不必关心前面 $k-1$ 枚硬币是怎么拼出 $n-a_k$ 的(可能有多种拼法, 在确定状态时不必深究), 也不知道$a_k$ 和 $k$ 的值, 唯一可以确定的是前面的步骤可以拼出$n-a_k$ 元
   2. 动态规划是寻找最优策略, 当拼出 $n$ 元面值时, 使用了最少的硬币组合, 则拼出 $n-a_k$ 元时, 使用的也是最优策略

   ![image-20210922100411292](https://gitee.com/four_four/picgo/raw/master/img/20210922100411.png) 

   原问题: 最少用多少枚硬币拼出 $n$ 元

   子问题: 最少用多少枚硬币拼出 $n-a_k$ 元
   子问题的子问题: 最少用多少枚硬币拼出  $n-a_k-a_{k-1}$ 元

   ……

   最终问题: 用一枚硬币拼出2/3/5元 或者 无法拼出(如1元就无法拼出)

   综上可得状态:

   ​	 $f(n) = 最少用多少枚硬币拼出 n 元 $ 
   ​      由不同的最后一步的结果的取值, 可以得到不同的子问题:

   $f(n)=f(n-2)+1$ 

   $f(n) = f(n-3)+1$ 

   $f(n)=f(n-5)+1$ 
   因为要求求得最少用多少硬币拼出$n$ , 所以:

   $f(n) = min\{ f(n-2)+1, f(n-3)+1, f(n-5)+1 \}$  

2. **确定转移方程**
   设状态 $f[n]=最少用多少枚硬币拼出n$
   ==方括号代表数组, $f[n]$ 中的$n$ 既代表金额, 又代表的是下标== 
   最终需要的最少的硬币数量
   $f[n]=min \{ f[n-2]+1, f[n-3]+1, f[n-5]+1 \}$ 

3. **初始条件与边界条件** 
   1. 边界条件: $n-2, n-5, n-7 < 0$ 时怎么办?
      如果 不能拼出$n$, 则设$f[n]=\infty$ 
      即 $f[-1]=f[-2]=...=\infty$  
      $\therefore f[1]=min\{f[-1]+1, f[-2]+1, f[-4]+1\}=\infty$ 
   2. 初始条件: $f[0]=0$ 

4. 计算顺序      一般都是从小到大计算

   1. $f[0]=0$ 
   2. 计算$f[1], f[2], ..., f[n]$ 
   3. 当计算$f[x]$时, $f[n-2], f[n-3], f[n-5]$ 都已经计算出来了

   ![image-20210922145144313](https://gitee.com/four_four/picgo/raw/master/img/20210922145144.png) 
   

> 代码实现

```c++
int getMinCount(int* coins, int coins_len, int money) {
    //定义状态数组
    int* f = new int[money+1];
    //初始状态
    f[0] = 0;

    //从小到大依次计算每一个状态
    for(int i = 1; i <= money; ++i) {
        //每一个状态  初始时设为正无穷
        f[i] = INT_MAX;
        //对于每一种状态, 前k-1枚硬币都是已知的,只需要求最后一枚硬币
        //这个循环是用来求最后一枚硬币的面值, 循环尝试每一个种面值
        for(int j = 0; j < coins_len; ++j) {
            // 判断能否使用该面值
            // 动态规划中下标不可能为负数
            if(i >= coins[j] && f[i-coins[j]] != INT_MAX) {
                f[i] = min(f[i], f[i-coins[j]]+1);
            }
        }
    }
    
    //返回最少使用的硬币数 -1说明无法拼出
    return f[money] == INT_MAX ? -1:f[money];

}
```

### 1.3.2 最值型

> 问题

机器人走$m*n$的网格, 机器人从$(0, 0)$出发, 每次只能向左或向右一步, 求走到右下角有多少种走法

> 解题思路

1. 确定状态
   最后一步:  机器人到达右下角   $(m-1, n-1)$ 的位置
   子问题: 前一个状态是 $(m-1, n-2) Or(m-2, n-1)$ 
   				如果机器人有$X$种方式从左上角走到 $(m-1, n-2)$ 和 $Y$ 种方式从左上角走到 $(m-2, n-1)$ , 则机器人有 $X+Y$ 种方式走到$(m-1, n-1)$ 
   				则原问题转化为机器人有多少种方式从左上角走到$(m-2, n-1)$ 和 $(m-1, n-2)$ 
   状态: $f[i][j]为机器人有多少种方式从左上角走到(i, j)$
2. 转移方程: $f[i][j] = f[i-1][j] + f[j-1][i]$  
   $f[i][j]: 机器人有多少种方式走到(i, j)$
   $f[i-1][j]: 机器人有多少种方式走到(i-1, j)$ 
   $f[i][j-1]: 机器人有多少种方式走到(i, j-1)$ 
3. 初始条件和边界情况
   + 初始条件:  $f[0][0] = 1$ 
   + 边界条件: $i=0 或 j =0时, 前进的方向只有一个$ 
4. 计算顺序
   二维数组, 逐行计算, 每一行从左到右
   1. $f[0][0] = 1$ 
   2. 计算第0行: $f[0][0], f[0][1], f[0][2], ..., f[0][n-1]$ 
   3. 计算第1行: $f[1][0], f[1][1], f[1][2], ..., f[1][n-1]$
   4. …
   5. 计算第m-1行: $f[m-1][0], f[m-1][1], f[m-1][2], ..., f[m-1][n-1]$  

> 代码实现

```c++
int PathNum(int m, int n) {
    //开辟一个 m行n列的数组
    int f[m][n];

    //逐行计算
    for(int i = 0; i < m; ++i) {
        //每一行从左往右计算
        for(int j = 0; j < n; ++j) {
            //边界条件的初始化: 第0行 和 第0列只有一种走法
            if(i == 0 || j == 0) {
                f[i][j] = 1;
            } else {
                //状态转移方程
                f[i][j] = f[i-1][j] + f[i][j-1];
            }
        }
    }

    return f[m-1][n-1];
}
```





### 1.3.3 存在型

> 问题

有 $n$ 块石头在 $x$ 轴的 $0, 1, 2, ... , n-1$ 的位置上
有一只青蛙想从石头$0$ 跳到 石头$n-1$ 的位置
已知青蛙在第i块石头上, 最多只能向右跳距离 $a_i$ 
问青蛙能否跳到石头$n-1$上

```
Input:n=5, a=[2, 3, 1, 1, 4]
Output:True
Input:n=5, a=[3, 2, 1, 0, 4]
Output:False
```

> 解题思路

1. 确定状态
   最后一步: 如果青蛙能跳到最后一块, 则最后一步为第 $n-1$块石头
   子问题: 青蛙能否跳到最后一步的前一块石头(设为 $i$) 
   青蛙能从第 $i$ 块石头跳到 第$n-1$块石头需要的条件:

   1. 青蛙可以跳到第 $i$ 块石头
   2. 从第$i$块是否到第$n-1$块石头之间的距离小于$a_i$ ($n-1-i <= a_i$) 

   由此可得状态 $f(j)为青蛙能否跳到第j个石头$ 

2. 确定转移方程
   $f[j]=OR_{0=<i<j}(f[i] \quad AND \quad j-i <=a[i])$  
3. 初始化与边界条件
   $f[0] = True$ 
4. 计算顺序
   1. $f[0] = True$ 
   2. 计算 $f[1], f[2], ... , f[n-1]$ 

> 代码实现

```c++
bool jump_game(int len, int* a) {
    //开一个len长度的数组存储状态
    bool f[len];
    int i, index;
    //f[0]初始化为true
    f[0] = true;
    //从左到右遍历每一个状态
    for(index = 1; index < len; ++index) {
            //每一个状态初始化为false
            f[index] = false;
        //从0开始, 遍历index之前的所有状态, 看从i出发能否到达index
        //只要有一个可以到达就可以
        for(i = 0; i < index; ++i) {
            //状态转移方程, 当满足方程时状态转为true, 并移动到下一个状态
            if(f[i] && index-i <= a[i]) {
                f[index] = true;
                break;
            }
        }

    }
    
    //返回能否到达最后一个石头
    return f[len-1];
}
```





### 1.3.4 最值型(较难)

> 问题

给定一个序列, 求连续子序列的最大乘积

```
Input: [2, 3, -1, 1]
Output: 6
```

> 解题思路

1. 确定状态
   最后一步:当给定一个序列时, 设它的乘积最大的最长子序列的最后一个为$a_k$ 

   子问题:

   1.  如果最长子序列只有1个, 那么就是$a_k$ 
   2. 如果不止一个
      1.  如果 $a_k < 0$ , 则 前面的连续子序列的乘积应当越小越好
      2. 如果$a_k > 0$ , 则前面的连续子序列的乘积应当越大越好
   3. 因此子问题可以分解成求以$a_{k-1}$ 结尾的最长的连续子序列

   状态:

   ​    $f[j]=以a[j]结尾的连续子序列的最大乘积$
   ​    $g[j] = 以a[j]结尾的连续子序列的最小乘积$ 

2. 转移方程
   由状态可以得到转移方程:
   $f[j] = max\{ a[j], max(a[j]*f[j-1], a[j]*g[j-1]) \}$ 
   $g[j] = min\{ a[j], min(a[j]*f[j-1], a[j]*g[j-1]) \}$

3. 初始条件和边界情况:
   + 对于情况2,  $a[j]$前至少应当由一个元素, 且 $j > 0$;
   + $f[0]=g[0]=a[0]$ 
4. 计算顺序
   1. $f[0], g[0], f[1], g[1], ... , f[n-1], g[n-1]$ 

> 代码实现

```c++
int maximum_product_subarray(int* a, int n) {
    //去除n==0的情况
    if(n==0) return 0;

    //开辟两个数组
    //f[n]存储连续子序列的最大乘积
    //g[n]存储连续子序列的最小乘积
    int f[n], g[n];
    //初始条件
    f[0] = a[0];
    //res 存储最大乘积
    int res = INT_MIN;
    //从左到右依次遍历每个状态
    for(int i = 1; i < n; ++i) {
        //如果a[i] >= 0
        //求最大乘积时, 前面的子序列的乘积越大越好
        //就最小乘积时, 前面的子序列的乘积越小越好
        if(a[i] >= 0) {
            f[i] = max(a[i], a[i] * f[i-1]);
            g[i] = min(a[i], a[i] * g[i-1]);
        } else {
        //如果a[i] < 0
        //求最大乘积时, 前面的子序列的乘积越小越好
        //就最小乘积时, 前面的子序列的乘积越大越好
            f[i] = max(a[i], a[i] * g[i-1]);
            g[i] = min(a[i], a[i] * f[i-1]);
        }
        res = max(res, f[i]);
    }

    return res;
}
```

