## 基本分段存储管理
### 分段
进程的地址空间: 按照程序**自身的逻辑关系划分为若干个段** , 每个段都有一个段名, **每个段都从0开始编址** 

内存分配原则: 以段为单位进行分配, **每个段在内存中占据连续空间**, 但**各段之间可以不相邻**. 

逻辑地址结构的组成: **段号 + 段内地址** 

### 段表

| 段号 | 段长 | 基址 |
| ---- | ---- | ---- |
| 0    | 7K   | 80K  |
| 1    | 3K   | 120K |
| ...  | ...  | ...  |

段号是隐藏的, 不占存储空间.

各个段表项的长度是相同的. 

段表项长: L<br>段号:K<br>段基址: M<br>K号段对应的段表项存放的物理地址: M+ K \* L

### 地址转换

![](https://gitee.com/four_four/picgo/raw/master/img/20211228192551.png)

1. 有逻辑地址得到段号, 段内地址
2. 段号与段表寄存器中的段长度比较, 检查是否越界
3. 又段表始址和段号得到对应表项
4. 根据段表中记录的段长, 检查段内地址是否越界
5. 由段表中的**基址+段内地址**得到最终的物理地址
6. 访问目标单元.



**与页表不同的是, 找到段表后, 仍需要判断段号有没有越界.
**
### 分段, 分页的对比
|                |              分段              |                  分页                  |
|:-------------- |:------------------------------:|:--------------------------------------:|
| 存在方式       |         信息的逻辑单位         |             信息的物理单位             |
| 主要目的       |       更好地方便用户编程       |    为了实现离散分配, 提高内存利用率    |
| 面向对象       |    面向用户, 对用户是可见的    |          面向系统, 用户不可见          |
| 地址空间的维度 | 一维<br>只需要给出逻辑地址即可 | 二维<br>既要给出段名, 又要给出段内地址 |
| 访存次数       |              2次               |                  2次                   |
| 是否可以加入快表机构               |      是                          |    是                                    |

同时, 分段也比分页更**容易实现信息的共享和保护**.

共享:

不能被修改的代码称为**纯代码**或**可重入代码**, 这样的代码是可以共享的.

只需要让各进程的段表项指向同一个段即可实现共享.

保护:

对于分段来说, 只需要设置段不允许其他进程访问即可.

分页: 

![](https://gitee.com/four_four/picgo/raw/master/img/20211228193829.png)

