
## 线程的实现方式
1. [[#用户级线程]]
2. [[#内核级线程]]
### 用户级线程
线程是通过线程库实现的, 操作系统意识不到线程的存在


#### 用户级线程的优缺点
优点:<br>用户级线程的切换在用户态下完成, 不需要切换成核心态, 线程管理的系统开销小, 效率高

缺点:<br>
当一个用户级线程被阻塞后, 整个进程都会被阻塞, 并发度不高.<br>
多个线程不能在多核处理机上并行运行
![](https://gitee.com/four_four/picgo/raw/master/img/20211226162332.png)

### 内核级线程
由操作系统支持的线程
![](https://gitee.com/four_four/picgo/raw/master/img/20211226162335.png)

#### 内核级线程的优缺点
优点:<br> 
并发度更高, 多线程可以在多核处理器上并发执行

缺点:<br>
切换线程的成本高, 开销大

### 用户级线程 vs 内核级线程
|                           | 用户级线程 | 内核级线程 |
|:------------------------- |:----------:|:----------:|
| 线程的管理                |  应用程序  |   处理机   |
| 线程的切换是否需要CPU变态 |   不需要   |    需要    |
| 操作系统能否意识到线程    |    不能    |     能     |



### 线程模型
#### 多对一线程模型
![](https://gitee.com/four_four/picgo/raw/master/img/20211226162338.png)

退化为 用户级线程, 优缺点同上 

#### 一对一模型
即 内核级模型, 优缺点同上

#### 多对多模型
 ![](https://gitee.com/four_four/picgo/raw/master/img/20211226162340.png)

n个线程映射为 m 个内核级线程, 每个进程对应m个内核级线程

克服了多对一模型中并发度不高的缺点, 也克服了一对一模型中线程切换开销过大的缺点

用户级线程是"代码逻辑"的载体, 内核级线程是"运行机会"的载体<br>
内核级线程中可以运行任意一个有映射关系的用户级线程代码, 只有m个内核级线程全部阻塞, 进程才阻塞

