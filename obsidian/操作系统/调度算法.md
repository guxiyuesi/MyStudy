## 调度算法
### 先来先服务算法( FCFS )
队列

优点: 公平, 算法实现简单

缺点: 排在长作业后面的短作业需要等待很长时间, **对长作业有利, 对短作业不利**
### 最短作业优先算法( SJF )
最短的作业/进程优先得到服务

优点: "最短的"平均等待时间, 平均周转时间

缺点: 不公平. 对短作业有利, 长作业不利. 可能导致饥饿.
### 最高响应比优先算法 (HRRN)
每次调度时先计算各个作业/进程的响应比, 选择响应比最高的作业/进程为其服务

$$响应比=\frac{等待时间+要求服务时间}{要求服务时间}$$

优点: 考虑了等待时间和运行时间, 综合了FCFS和SJF算法的优点
### FCFS, SJF, HRRN算法的对比
||用于作业/进程调度|是否可抢占|是否会导致饥饿|特点|
|:---|:---:|:---:|:---:|:---|
|FCFS|均可|不可抢占|不会|对长作业有利, 对短作业不利|
|SJF|均可|不可.SRTN是可抢占的SJF|会|对短作业有利, 长作业不利|
|HRRN|均可|不可|不会|综合了FCFS和SJF的优点|

**注: 这几个算法适用于批处理系统** , FCFS结合其他算法, 在交互式系统中也常使用.

### FCFS, SJF, HRRN算法举例
各进程到达就绪队列的时间, 需要运行的时间如下表所示. 计算各进程的周转时间和带权周转时间.

|进程|到达时间|运行时间|
|:---|:---:|---:|
|P1|0|7|
|P2|2|4|
|P3|4|1|
|P4|5|4|

FCFS:

执行顺序: P1 -> P2  -> P3 -> P4

周转时间:<br>
P1 = 7-0 = 7<br>
P2 = (7+4)-2 = 9<br>
P3 = (7+4+1) - 4 = 8<br>
P4 = (7+4+1+4) - 5 = 11

带权周转时间:<br>
P1 = 7 / 7 = 1<br>
P2 = 9 / 4 = 2.25<br>
P3 = 8 / 1 = 8<br>
P4 = 11 / 4 = 2.75


SJF:<br>
执行顺序: P1 -> P3 -> P2 -> P4

周转时间:<br>
p1 = 7 - 0 = 7<br>
P3 = 7 + 1 - 4 = 4<br>
P2 = 7 + 1 + 4 - 2 = 10<br>
P4 = 7 + 1 + 4 + 4 - 5 = 11

带权周转时间:<br>
P1 = 7 / 7 = 1<br>
P3 = 4 / 1 = 4<br>
P2 = 10 / 4 = 2.5 <br>
P4 = 11 / 4 = 2.75

HRRN:

执行顺序: P1 -> P3 -> P2 -> P4

周转时间与带权周转时间与SJF相同

### 时间片轮转算法(RR)
按照各进程到达就绪队列的顺序, 轮流让各个进程执行一个时间片. 若进程未在一个时间片内执行完, 则剥夺处理机, 将进程重新放到就绪队列队尾重新排队.

抢占式算法.

优点: 公平; 响应快.

缺点: 高频率的进程切换会有一定的开销; 不区分任务的紧急程度.

不会导致饥饿.




### 优先级调度(HPF)
调度时选择优先级最高的作业/进程

可用于: 作业调度 / 进程调度 / IO调度

抢占式, 非抢占式都有. 

优点: 用优先级区分紧急程度, 重要程度, 适用于实时操作系统. 可以灵活地调整对各种作业/ 进程的偏好程度.

缺点: 如果有源源不断的高优先级的进程到来, 可能导致饥饿. 

#### 确定优先级
优先级的分类: 根据优先级是否可以动态调整, 将优先级分为: **动态优先级** 和 **静态优先级** 两种

通常: 
1. 系统进程 > 用户进程
2. 前台进程 > 后台进程
3. 操作系统更偏好 **I/O 型进程** . <br> 原因: I/O设备和CPU可以[[并发#并发与并行的区别|并行]]工作. <br>优先让I/O型进程运行, I/O设备就可能更早的投入工作, 资源利用率, 系统吞吐量都会提升

动态优先级调整的时机:<br>
可以从**追求公平, 提升资源利用率**等角度考虑
1. 某个进程在就绪队列中等待很长时间, 可以适当提升其优先级
2. 某进程占用处理机运行很长时间, 可以适当降低其优先级
3. 某个进程频繁进行I/O操作, 可以适当提升其优先级
### 多级反馈队列(FB)

可用于进程调度

抢占式算法

设置多个就绪队列, 各级队列优先级**从高到低**, 时间片**从小到达**

新进程到达时**先进入第一级队列**, 按**FCFS原则**排队等待被分配时间片. 若用完时间片进程**还未结束**, 则进入**下一级队列队尾**. 如果已经处于最下级队列, 则**重新放回最下级队列队尾**.

只有**第k级队列为空**时, 才会为**k+1级队列中队头的进程分配时间片**

### RR, HPF, FB算法举例

[HPF算法举例](file:///E:/%5CStudyVedio%5Ctest%5Ctest.mp4#t=1083.081142)

[RR算法举例](file:///E:/%5CStudyVedio%5Ctest%5Ctest.mp4#t=206.096749)

[FB算法举例](file:///E:/%5CStudyVedio%5Ctest%5Ctest.mp4#t=1770.285867)
