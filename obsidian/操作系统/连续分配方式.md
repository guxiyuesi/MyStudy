## 连续分配方式
### 单一连续分配
单一连续分配中, 内存被分为 **系统区** 和 **用户区**, 系统区通常位于内存的低地址位置

内存中 **只能有一道用户程序** 

优点: 实现简单; 无[[外部碎片]] , 可以采用[[覆盖技术]]扩充内存; 可以不采用内存保护

缺点:
1. 只适用于单用户单任务的操作系统
2. 有[[内部碎片]]
3. 存储器利用率极低


### 固定分区分配
把用户空间划分为若干个固定大小的分区, 每个分区只装入一道作业

固定分区的方式:
1. 分区大小相同<br>缺乏灵活性, 但**很适合用于用一台计算机控制多个相同对象的集合** 
2. 分区大小不同<br>增加了灵活性

优点: 实现简单, 无[[外部碎片]]

缺点: 
1. 用户程序太大时, 必须采用[[覆盖技术]]来解决, 降低性能
2. 会产生[[内部碎片]]

固定分区分配对应的数据结构: **分区说明表** 

 | 分区号 | 大小(MB) | 起始位置(MB) | 状态   |
 | ------ | -------- | ------------ | ------ |
 | 1      | 2        | 8            | 未分配 |
 | 2      | 2        | 10           | 未分配 |
 | ...    | ...      | ...          | ...    |

### 动态分区分配
不会预先划分内存分区, 在进程装入时, 根据进程的大小动态的建立分区

分配:
[[动态分区分配算法]]

回收:
[[动态分区匹配的回收]]