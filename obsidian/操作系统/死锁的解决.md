## 死锁的解决
### 预防死锁
即破坏死锁的四个必要条件中的任意一个或多个, 使死锁无法产生.

互斥条件不能破坏, 因为这个非共享设备所必须的.所以只能破坏其他三个条件.

#### 破坏请求与保持条件
第一种协议:

所有进程在开始运行之前, 必须一次性申请其在整个运行过程中所需的所有资源.

缺点:
1. 会造成资源的严重浪费, 降低系统的吞吐量
2. 可能导致进程饥饿

第二种协议:

在获得运行初期所必需的资源后, 便开始运行. 进程运行过程中再逐步释放已分配给自己的, 且已用毕的全部资源, 然后再请求新的所需资源.


#### 破坏不可抢占条件

当一个进程已经保持了某些不可抢占的资源后, 提出新的资源请求不能被满足时, 必须立刻释放所拥有的所有资源, 需要时再重新申请.

缺点:
1. 复杂, 代价大
2. 可能导致进程饥饿


#### 破坏循环等待条件

对系统中的所有资源进行线性排序, 规定每个进程都必须按照序号递增的顺序来请求资源.

优点:
1. 资源利用率和系统吞吐量都明显提升

缺点:
1. 新增设备比较麻烦
2. 作业使用资源的顺序和系统规定的顺序不同, 引起资源浪费
3. 限制用户自主简单的编程


### 避免死锁
确保资源始终处于安全状态

一个系统开始是处于安全状态的, 当有进程请求一个可用资源时, 系统需要对该进程的请求进行计算, 若将资源分配给进程后系统仍然是安全的, 才将该资源分配给该进程.

重点: 银行家算法

#### 银行家算法
Max: 进程对资源的最大需求量

Allocation: 进程已分配的资源量

Need: 进程还需的资源量

Available: 可利用的资源向量 (等价于安全性算法中的Work)

Request: 请求向量

银行家算法的流程:
1. 当有一个进程提出新的资源时, 先检查 Request <= Need 是否成立
2. 再检查Request <= Available 是否成立
3. 若都成立, 尝试将该资源分配给该进程, 然后利用安全性算法, 查看是否能找到一个安全序列
4. 若能, 则 将该资源分配给进程; 否则, 进程阻塞

银行家算法举例如下:

| 进程 |    Max    | Allocation |      Need |
|:---- |:---------:|:----------:| ---------:|
| P1   | (7, 5, 3) | (0, 1, 0)  | (7, 4, 3) |
| P2   | (3, 2, 2) | (2, 0, 0)  | (1, 2, 2) |
| P3   | (9, 0, 2) | (3, 0, 2)  | (6, 0, 0) |
| P4   | (2, 2, 2) | (2, 1, 1)  | (0, 1, 1) |
| P5   | (4, 3, 3) | (0, 0, 2)  | (4, 3, 1) |


$Available(3, 3, 2), Request_2(1, 0, 2)$

1. $Request_2(1, 0, 2) < Need_2(1, 2, 2)$ 成立
2. $Request_2(1, 0, 2) < Available(3, 3, 2)$ 成立
3. 尝试分配后使用安全性算法:

| 进程 |   Work    |   Need    | Allocation | Work+Allocation | Finish |
|:---- |:---------:|:---------:|:----------:|:---------------:| ------:|
| P2   | (2, 3, 0) | (0, 2, 0) | (3, 0, 2)  |    (5, 3, 2)    |   true |
| P4   | (5, 3, 2) | (0, 1, 1) | (2, 1, 1)  |    (7, 4, 3)    |   true |
| P5   | (7, 4, 3) | (4, 3, 1) | (0, 0, 2)  |    (7, 4, 5)    |   true |
| P1   | (7, 4, 5) | (7, 4, 3) | (0, 1, 0)  |    (7, 5, 5)    |   true |
| P3   | (7, 5, 5) | (6, 0, 0) | (3, 0, 2)  |   (10, 5, 7)    |   true |

检查正确, 可以分配.

### 死锁的检测与解除
