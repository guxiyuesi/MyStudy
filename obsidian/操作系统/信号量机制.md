## 信号量机制

### 信号量
信号量其实就是一个变量, **可以是一个整数, 也可以是更复杂的记录型变量**. 可以用一个信号量来**表示系统中某种资源的数量** 

操作系统使用一对 [[操作系统的体系结构#^c8e193|原语]] 来对信号量进行操作(P, V操作, 使用wait原语和signal原语)

### 整型信号量
用一个**整数型的变量**作为信号量, 用来表示**系统中某种资源的数量** 
```c
int S = 1;

void wait(int S) {      //wait原语, 相当于进入区
	while(S <= 0);      //如果资源数不够, 就循环等待
	S = S-1;            //如果资源数够, 就占用一个资源
}

void signal(int S) {    //signal原语, 相当于退出区
	S = S+1;            //使用完资源后, 在退出区释放资源
}
```

本质上是使用原语实现的双标志先检查法, "检查" 和 "上锁" 的操作是原子性的, 避免了并发带来的异步问题

依然不满足"让权等待"的原则, 会出现忙等

整型信号量只能 进行初始化, P操作, V操作

### 记录型信号量
解决整型信号量出现忙等的问题

```c
//记录型信号量的定义
typedef struct {
	int value;         //剩余资源数
	struct process *L; //等待队列
}semaphore;

S.value = 2;

void wait(S) {    //P(S)
	S.value --;
	if(S.value < 0) {   
		//如果剩余资源数不够, 则使用block原语使进程由运行态变为阻塞态, 并挂到信号量S的等待队列中(阻塞队列)
		block(S.L);
	}
}

void signal(S) {   //V(S)
	S.value ++;
	if(S.value <= 0) {
		//释放资源后, 如果还有别的进程在等待这种资源, 则使用wakeup原语唤醒等待队列中的一个进程, 使该进程从阻塞态变成就绪态
		wakeup(S.L);
	}
}
```
通过调用的block原语, 可以实现"让权等待"的原则;
wakeup原语, 可以实现"闲则进"的原则.