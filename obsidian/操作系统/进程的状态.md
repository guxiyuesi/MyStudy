### 进程的状态

1. **就绪状态**(基础状态) <br/> 程序已经获取除CPU以外的所有资源, 一旦获取CPU就可以执行 <br/>就绪状态下的进程存在就绪队列中, 依据一定的规则等待获取CPU权限
2. **执行状态**(基础状态) <br/> 程序获得CPU后, 正在执行的状态
3. **阻塞状态**() <br/> 程序执行时, 因某些原因被阻塞(如I/O), 无法继续执行, 就会进入阻塞状态.   阻塞状态下的进制存放在阻塞队列中

基础状态下的进程状态转换:

```mermaid
graph TD

A((就绪))
B((执行))
C((阻塞))

A --> |进程调度|B
B --> |时间片完|A
B --> |I/O请求|C
C --> |I/O完成|A
```

执行态 到 阻塞态 是进程发出"[[系统调用]]"引起的, 是进程主动的行为

阻塞态 到 就绪态 是操作系统控制的, 进程无法控制


4. **创建状态**: 


进程的创建步骤: 
1. 申请空白PCB块 并向PCB块中写入控制和管理进程信息<br/>
2.  申请进程运行所必须的资源 <br/> 
3.  将进程的状态转化为就绪状态并将进程插入到就绪队列中

当步骤2或3出现问题时, 程序没有创建完成, 即<br>
1.未能申请到进程运行所必须的资源<br>
2.就绪队列已满<br>
则进程会停留在创建状态

引入创建状态的作用:<br>
保证进程必须是在创建后才被执行, 确保PCB的完整性

5. **终止状态**:<br>

进程终止的步骤:<br>
1.操作系统进行善后处理<br>
2.PCB清零并回收PCB空间<br>

进程进入终止状态的原因:<br>
1.进程到达自然结束点<br>
2.进程遇到无法克服的错误<br>
3.操作系统强制结束<br>
4.有终止权限的进程强行终止<br>

引入创建和终止状态后的进程状态转换:
```mermaid
graph TD

A((创建))
B((就绪))
C((执行))
D((阻塞))
E((终止))

A --> |许可|B
B --> |进程调度|C
C --> |时间片完|B
C --> |I/O请求|D
D --> |I/O结束|B
C --> |释放|E

```


6. 挂起与激活操作

为了方便系统和用户观察和分析进程, 引入挂起操作. 被挂起的进程被称为静止进程, 不能被CPU调用. <br>只有处于就绪状态和阻塞状态的进程可以被挂起<br>
激活操作与挂起操作相对应

为了描述挂起和激活, 将就绪状态分为 活动就绪 和 静止就绪, 
将阻塞状态分为 活动阻塞 和 静止阻塞

引入挂起和激活操作后的状态转换:
```mermaid
graph TD

A((创建))
BA((活动就绪))
BB((静止就绪))
C((执行))
DA((活动阻塞))
DB((静止阻塞))
E((终止))

A --> |许可|BA
A --> |许可|BB
BA --> |进程调度|C
BA --> |挂起|BB
BB --> |激活|BA
C --> |时间片完|BA
C --> |I/O请求|DA
C --> |释放|E
C --> |挂起|BB
DA --> |I/O完成|BA
DA --> |挂起|DB
DB --> |激活|DA
DB --> |释放|BB
```


进程PCB中, 会有一个寄存器state用来保存进程的状态

### 进程的组织
为了将同一状态下的各个进程统一进行管理, 操作系统会把各个进程的PCB组织起来

#### 链接方式
```mermaid
graph TD

A((执行<br/>指针)) --> P1((PCB1))
B((就绪队列<br/>头指针)) --> P2((PCB2)) --> P3((PCB3))
C((阻塞队列<br/>头指针)) --> P4((PCB4)) --> P5((PCB5)) 
```

#### 索引方式

![](https://gitee.com/four_four/picgo/raw/master/img/20211128170425.png)



